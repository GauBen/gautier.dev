---
title: Bundling a SvelteKit app into a single binary
description: The odyssey of packaging a SvelteKit application using the upcoming Single Executable Application (SEA) Node feature through a custom adapter.
snippet:
  lang: js
  code: >
    await postject.inject(
      "node",
      "NODE_SEA_BLOB",
      readFileSync("./bundle.blob"),
      { sentinelFuse: "NODE_SEA_FUSE​_fce680ab2cc467b6e072b8b5df1996b2" },
    );
---

<script>
  import { Table, Tldr } from '$lib/markdown';
</script>

<Tldr>

Yep, it works, you can pack the `node` executable, JS code and assets into a single binary with a custom SvelteKit adapter. I opened [an issue](https://github.com/sveltejs/kit/issues/15101) to discuss adding an official adapter for this.

</Tldr>

## Background

It's common in the Go ecosystem to ship complete full-stack applications as a single binary. For instance, the [log analyzer GoAccess](https://goaccess.io/) has a built-in web dashboard and ships as a single executable. This ecosystem usually relies on the [embed package](https://pkg.go.dev/embed) to achieve this.

Since version 19, Node has an experimental feature called [Single Executable Application (SEA)](https://nodejs.org/api/single-executable-applications.html) that allows bundling the Node.js runtime, application code, and assets into a single executable file.

A hello world example is provided in the documentation, here is what it looks like on Linux:

```bash
# Create a hello.js program and its SEA configuration file
echo 'console.log(`Hello, ${process.argv[2]}!`);' > hello.js
echo '{ "main": "hello.js", "output": "sea-prep.blob" }' > sea-config.json

# Generate the SEA blob to be injected in the node binary
node --experimental-sea-config sea-config.json

# Make a copy of the node binary
cp $(command -v node) hello

# Embed the blob into the node binary copy
npx postject hello NODE_SEA_BLOB sea-prep.blob \
  --sentinel-fuse NODE_SEA_FUSE​_fce680ab2cc467b6e072b8b5df1996b2

# Run the resulting single executable application
./hello world
# > Hello, world!
```

The `sea-config.json` file is where we list all resources we want to bundle into the final executable. In this case, it's just the `hello.js` file, but we can also include assets like CSS and images.

The most binding constraint is that **the `main` program must be a single CommonJS file, with no external dependencies nor top-level `await`s.** Since SvelteKit applications are made of multiple ESM modules, we'll have to bundle our dummy application (this website) into a single CommonJS file before we can package it as a SEA binary.

## SvelteKit Adapters

When building a SvelteKit application for production, we use an [adapter](https://svelte.dev/docs/kit/adapters) to generate the production artifact. For instance the [`@sveltejs/adapter-node`](https://svelte.dev/docs/kit/adapter-node) adapter generates JS code made to be run with Node.js.

The build process of a SvelteKit application is in two steps:

1. Vite transpiles all source files into JS, CSS and assets into the `.svelte-kit/output` directory. The code is runtime-agnostic at this point.

2. The adapter takes the output of Vite and produces the production files in the `build` directory, compatible with the target runtime.

We will create an `adapter-node-sea` adapter that will take, as input, the output of Vite and produce a SEA binary as output.

Let's start with a Proof of Concept: serving server-side rendered (SSR) pages, ignoring static assets and prerendered pages for now. Here is what an empty adapter looks like:

```ts
export default function adapter(): Adapter {
  return {
    name: "adapter-node-sea",

    async adapt(builder) {
      // `builder` is an object provided by SvelteKit that gives us access to
      // the build output and methods to write the final files
    },
  };
}
```

The first step is creating a work directory where we will produce intermediate files:

```ts
// Create an empty temporary build directory
const tmp = builder.getBuildDirectory("sea");
builder.rimraf(tmp);
builder.mkdirp(tmp);

// Copy the server code generated by SvelteKit
builder.writeServer(`${tmp}/server`);
```

We create a temporary build directory (`.svelte-kit/sea`) and copy the runtime-agnostic server code generated by SvelteKit into it.

To produce our CommonJS bundle, we will use [Rolldown](https://rolldown.rs/):

```ts
await rolldown.build({
  input: "virtual:entry",
  cwd: resolve(tmp), // Resolve all paths relative to the temporary directory
  platform: "node",
  output: {
    // Produce a CommonJS bundle with all dependencies inlined
    format: "cjs",
    inlineDynamicImports: true,
    file: "bundle.js",
  },
  plugins: [
    {
      // This plugin defines the `virtual:entry` module used as input
      name: "virtual-entry",
      resolveId(id) {
        if (id === "virtual:entry") return id;
      },
      load(id) {
        if (id === "virtual:entry") {
          return `import { getRequest, setResponse } from "@sveltejs/kit/node";
import polka from "polka";
import { Server } from "./server/index.js";

const app = new Server(${builder.generateManifest({ relativePath: "./server" })});

const ssr = async (req, res) => {
  let request;

  try {
    request = await getRequest({
      base: "http://localhost:3000",
      request: req,
      bodySizeLimit: 512_000,
    });
  } catch {
    res.statusCode = 400;
    res.end("Bad Request");
    return;
  }

  await setResponse(
    res,
    await app.respond(request, {
      platform: { req },
      getClientAddress: () => {
        return (
          req.connection?.remoteAddress ||
          req.connection?.socket?.remoteAddress ||
          req.socket?.remoteAddress ||
          req.info?.remoteAddress
        );
      },
    }),
  );
};

const server = polka().use(ssr);

const host = "0.0.0.0";
const port = 3000;

app.init({ env: process.env }).then(() => {
  server.listen({ host, port }, () => {
    console.log("Listening on http://%s:%s", host, port);
  });
});`;
        }
      },
    },
  ],
});
```

This code could be improved, but it does the job---we give Rolldown a virtual entry point that does the following:

- Import the SvelteKit runtime-agnostic `Server` and create an instance of it. This class is not application-specific, we inject the application routes and logic through a manifest (`builder.generateManifest()`).

- Create a [Polka](https://www.npmjs.com/package/polka) HTTP server that listens on port 3000 and forwards all requests to the SvelteKit server instance. The SSR logic is handled by SvelteKit's `app.respond()` method.

- Node-specific `IncomingMessage` HTTP requests are converted to standard `Request` using SvelteKit's `getRequest` utility, then the response is converted back to Node's `ServerResponse` using `setResponse`.

This code is a simplified version of what [the official `@sveltejs/adapter-node` adapter does](https://github.com/sveltejs/kit/blob/9e9fd2d024fa08e56c8e3e141e38e04fa4e118a0/packages/adapter-node/src/handler.js#L97-L160).

At this point, we have a single `bundle.js` file in CommonJS format that contains all the application code and dependencies. We now need to:

1. Create the SEA configuration file;
2. Copy the `node` binary;
3. Generate the SEA blob;
4. Inject the blob into the `node` binary.
5. Copy the resulting binary to the final output directory.

With real code, it looks like this:

```ts
writeFileSync(
  `${tmp}/sea-config.json`,
  JSON.stringify({ main: `${tmp}/bundle.js`, output: `${tmp}/bundle.blob` }),
);

builder.copy(process.execPath, `${tmp}/node`);

execFileSync(`${tmp}/node`, [
  "--experimental-sea-config",
  `${tmp}/sea-config.json`,
]);

// API version of `npx postject`
await postject.inject(
  `${tmp}/node`,
  "NODE_SEA_BLOB",
  readFileSync(`${tmp}/bundle.blob`),
  { sentinelFuse: "NODE_SEA_FUSE​_fce680ab2cc467b6e072b8b5df1996b2" },
);

const out = "build";
builder.rimraf(out);
builder.mkdirp(out);
builder.copy(`${tmp}/node`, `${out}/app`);
```

And _voilà!_ Running `vite build` will produce a binary at `build/app` that you can be run directly:

```bash
$ ./build/app
Listening on http://0.0.0.0:3000
```

Opening [localhost:3000](http://localhost:3000) will render a plain HTML page:

<figure>
<enhanced:img src="./plain-html.png?w=800" alt="The homepage of this very website, without CSS" />
<figcaption>We're halfway there</figcaption>
</figure>

## Static Assets

It's a great start, at least to my eyes, but I could get that yours are hurt by the lack of CSS. **Let's enrich our POC to bundle client assets as well.** The implementation primitives we'll use are:

- The [`assets`](https://nodejs.org/api/single-executable-applications.html#assets) key of the SEA configuration file, listing all static assets to be bundled.
- The [`getRawAsset(key: string)`](https://nodejs.org/api/single-executable-applications.html#seagetrawassetkey) Node API to retrieve assets at runtime. I assumed this API is faster than the others because it does not make a copy of the asset buffer prior to returning it, but that remains to be benchmarked.

We first ask the builder to write the client assets to the temporary directory:

```ts
const client = builder.writeClient(`${tmp}/client`);
```

The `client` variable is an array of all files written by the builder, that we then inject into the SEA configuration:

```ts
writeFileSync(
  `${tmp}/sea-config.json`,
  JSON.stringify({
    main: `${tmp}/bundle.js`,
    output: `${tmp}/bundle.blob`,

    // This is new part: a file -> path mapping
    assets: Object.fromEntries(
      client.map((file) => [`/${file}`, `${tmp}/client/${file}`]),
    ),
  }),
);
```

Last but not least, we need to serve these assets with our Polka server:

```ts
import { getRawAsset, getAssetKeys } from "node:sea";
import { lookup } from "mrmime";

// A set of all bundled asset keys for quick existence checking
const knownAssets = new Set(getAssetKeys());

const server = polka()
  .get("/*", (req, res, next) => {
    if (!knownAssets.has(req.path)) {
      next();
      return;
    }

    const asset = getRawAsset(req.path);
    res.setHeader(
      "Content-Type",
      lookup(req.path) || "application/octet-stream",
    );
    res.end(Buffer.from(asset));
  })
  .use(ssr);
```

This is a very naive asset server---`@sveltejs/adapter-node` uses [`sirv`](https://www.npmjs.com/package/sirv) under the hood to serve assets with proper caching headers and compression. This is not an option here as `sirv` relies on the filesystem, but it's a proof of concept, let's move on.

Let's try that out by rebuilding (`vite build`) and reruning (`./build/app`) the application:

<figure>
<enhanced:img src="./with-assets.png?w=800" alt="The homepage of this very website, with CSS" />
<figcaption>Enjoy the <em>websiteception</em></figcaption>
</figure>

And that's it! We are still lacking many features like prerendering support, but **I consider this proof of concept a success.**

## But Why?

_insert Ryan Reynolds meme_

Why would anyone want to bundle a SvelteKit application into a single binary?

Apart from the ease of distribution, I'm curious about the performance implications of bundling everything into a single binary. I compared the runtime performance of the `@sveltejs/adapter-node` build versus our `adapter-node-sea` build using [oha](https://github.com/hatoo/oha):

<Table>
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th><code>@sveltejs/adapter-node</code></th>
      <th><code>adapter-node-sea</code></th>
      <th>Difference</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="3">Homepage</td>
      <td>p50</td>
      <td align="right">171.6 ms</td>
      <td align="right">105.7 ms</td>
      <td align="right"><strong>-38%</strong></td>
    </tr>
    <tr>
      <td>p90</td>
      <td align="right">220.3 ms</td>
      <td align="right">140.9 ms</td>
      <td align="right"><strong>-36%</strong></td>
    </tr>
    <tr>
      <td>p95</td>
      <td align="right">254.5 ms</td>
      <td align="right">460.1 ms</td>
      <td align="right"><strong>+81%</strong></td>
    </tr>
    <tr>
      <td rowspan="3">Largest asset (280 kB)</td>
      <td>p50</td>
      <td align="right">45.9 ms</td>
      <td align="right">11.7 ms</td>
      <td align="right"><strong>-75%</strong></td>
    </tr>
    <tr>
      <td>p90</td>
      <td align="right">51.3 ms</td>
      <td align="right">17.5 ms</td>
      <td align="right"><strong>-66%</strong></td>
    </tr>
    <tr>
      <td>p95</td>
      <td align="right">53.8 ms</td>
      <td align="right">50.8 ms</td>
      <td align="right"><strong>-6%</strong></td>
    </tr>
    <tr>
      <td rowspan="3">Smallest asset (83 B)</td>
      <td>p50</td>
      <td align="right">17.3 ms</td>
      <td align="right">7.1 ms</td>
      <td align="right"><strong>-59%</strong></td>
    </tr>
    <tr>
      <td>p90</td>
      <td align="right">21.5 ms</td>
      <td align="right">11.1 ms</td>
      <td align="right"><strong>-48%</strong></td>
    </tr>
    <tr>
      <td>p95</td>
      <td align="right">22.9 ms</td>
      <td align="right">13.6 ms</td>
      <td align="right"><strong>-41%</strong></td>
    </tr>
  </tbody>
</Table>

**The performance boost is quite significant!** We have this p95 outlier on the homepage that I can't explain (and don't intend to investigate further right now), but overall the SEA binary is consistently faster than the standard Node.js build.

## Conclusion

The SEA feature of Node.js is very promising, enabling self-contained applications with minimal ceremony. Even my naive implementation suggests significant performance gains compared to a Node.js build---for small SvelteKit apps like this website at least.

I created a [SvelteKit issue](https://github.com/sveltejs/kit/issues/15101) to discuss adding an official `@sveltejs/adapter-node-sea` adapter to the SvelteKit ecosystem. If you are interested, please upvote!
